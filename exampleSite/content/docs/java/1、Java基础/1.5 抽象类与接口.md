# 抽象类与接口

## 1 抽象类

1. 在了解抽象类之前，先来了解一下抽象方法，**抽象方法是一种特殊的方法**，他**只有声明**，而**没有具体的实现**，抽象方法的声明格式为：

   ```java
   abstract void fun();
   ```
2. **抽象方法必须用 `abstract` 关键字修饰**，**如果一个类含有抽象方法**，**则称这个类为抽象类**，**抽象类必须在类前用 `abstract` 关键字修饰**，因为**抽象类中含有无具体实现的方法**，所以**不能用抽象类创建对象**。
3. 包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，他和普通类一样，同样**可以拥有成员变量和普通的成员方法**，抽象类和普通类主要有以下区别：

   1. **抽象方法必须为 `public` 或者 `protected`**（因为如果为`private`，则不能被子类继承，子类便无法实现该方法），**缺省情况下默认为 `public`**。
   2. **抽象类不能用来创建对象**，因为**抽象类中含有无具体实现的方法**。
   3. **如果一个类继承于一个抽象类**，**则子类必须实现父类的抽象方法**，**如果子类没有实现父类的抽象方法**，**则必须将子类也定义为 `abstract` 类**。
      其他方面，抽象类和普通类并没有区别。

## 2 接口

1. 接口，英文称作 `interface`，**泛指供别人调用的方法或者函数**，他**是对行为的抽象**，定义一个接口的格式如下：

   ```java
   [public] interface InterfaceName {

   }
   ```
2. 接口中**可以含有变量和方法**，但是要注意，**接口中的变量会被隐式地指定为 `public static final` 变量**（并且只能是 `public static final` 变量，用 `private` 修饰会报编译错误），而**方法会被隐式地指定为 `public abstract` 方法**（并且只能是 `public abstract` 方法，用 `private`、`protected` 等修饰会报编译错误），并且**接口中所有的方法不能有具体的实现**，也就是说，**接口中的方法必须都是抽象方法**，因此**接口是一种极度抽象的类型**，**他比抽象类更加抽象**，并且**一般情况下不在接口中定义变量**。
3. 要让一个类遵循某组特定的接口需要使用 `implements` 关键字，具体格式如下：

   ```java
   class className implements Interface1, Interface2, [....] {

   }
   ```

   可以看出，**允许一个类遵循多个特定的接口**，**如果一个非抽象类遵循了某个接口**，**就必须实现该接口中的所有方法**，**对于遵循某个接口的抽象类**，**可以不实现该接口中的抽象方法**。

## 3 抽象类和接口的区别

### 3.1 语法层面

1. **抽象类可以提供成员方法的实现细节**，而**接口中只能存在 `public abstract` 方法**。
2. **抽象类中的成员变量可以是各种类型的**，而**接口中的成员变量只能是 `public static final` 类型的**。
3. **接口中不能含有静态代码块以及静态方法**，而**抽象类可以有静态代码块和静态方法**。
4. **一个类只能继承一个抽象类**，而**一个类却可以实现多个接口**。

### 3.2 设计层面

1. **抽象类是对一种事物的抽象**，即**对类整体进行抽象**，**包括属性**、**行为**，而**接口是对行为的抽象**，即**对类局部进行抽象**：
   1. 举个简单的例子，飞机和鸟是不同类的事物，但是他们都有一个共性，就是都会飞，那么在设计的时候，可以将飞机设计为一个类`AirPlane`，将鸟设计为一个类`Bird`，但是不能将飞行这个特性也设计为类，因此他只是一个行为特性，并不是对一类事物的抽象描述。
   2. 此时可以将飞行设计为一个接口`Fly`，包含方法`fly()`，然后`AirPlane` 和`Bird` 分别根据自己的需要实现`Fly` 这个接口。
   3. 然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承`AirPlane` 即可，对于鸟也是类似的，不同种类的鸟直接继承`Bird` 类即可。
   4. 从这里可以看出，**继承是一个「是不是」的关系**，而**接口实现则是「有没有」的关系**，**如果一个类继承了某个抽象类**，**则子类必定是抽象类的种类**，而**接口实现则是「有没有」**、**「具备不具备」的关系**，比如鸟是否能飞，能飞则可以实现这个接口，不能飞就不实现这个接口。
2. **抽象类作为很多类的子类**，**他是一种模板式设计**，而**接口是一种行为规范**，**他是一种辐射式设计**：
   1. 对于模板式设计，最简单的例子就是 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，则 ppt B 和 ppt C 公共的部分就是模板 A 了，如果他们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。
   2. 而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。
   3. 也就是说**对于抽象类**，**如果需要添加新的方法**，**可以直接在抽象类中添加具体的实现**，**子类可以不进行变更**，而**对于接口**，**如果接口进行了变更**，**则所有实现这个接口的类都必须进行相应的改动**。
   4. 下面看一个门和警报的例子：
      1. 门都有 `open()` 和 `close()` 两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：

         ```java
         abstract class Door {
           public abstract void open();
           public abstract void close();
         }
         ```

         或者：

         ```java
         interface Door {
           public abstract void open();
           public abstract void close();
         }
         ```
      2. 但是现在如果我们需要门具有报警 `alarm()` 的功能，可以有以下两种方式来实现：

         1. 将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是又的门并不一定具备报警功能。
         2. 将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的 `open()` 和 `close()`，也许这个类根本就不具备 `open()` 和 `close()` 这两个功能，比如火灾报警器。
         3. 从这里可以看出，`Door` 的 `open()`、`close()` 和 `alarm()` 根本就属于两个不同范畴内的行为，`open()` 和 `close()` 属于门本身固有的行为特性，而 `alarm()` 属于延伸的附加行为，因此最好的解决办法是单独将报警设计为一个接口，包含 `alarm()` 行为，`Door` 设计为单独的一个抽象类，包含 `open()` 和 `close()` 两种行为，再设计一个报警门继承 `Door` 类和实现 `Alarm` 接口：

            ```java
            interface Alarm {
              void alarm();
            }
            ```

            ```java
            abstract class Door {
              void open();
              void close();
            }
            ```

            ```java
            class AlarmDoor extends Alarm implements Door {
              void open() {
                //....
              }

              void close() {
                //....
              }

              void alarm() {
                //....
              }
            }
            ```

## 参考文献

1. [深入理解 Java 的接口和抽象类](https://www.cnblogs.com/dolphin0520/p/3811437.html)。
