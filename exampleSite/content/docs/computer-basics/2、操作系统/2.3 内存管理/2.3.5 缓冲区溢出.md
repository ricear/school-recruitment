---
weight: 5
---

# 缓冲区溢出

## 1 什么是缓冲区溢出

1. C 语言使用运行时栈来存储过程信息。
2. 每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。
3. C 语言对数组引用不进行任何边界检查，因此**对越界的数组元素的写操作会破坏存储在栈中的状态信息**，这种现象称为缓冲区溢出。
4. 缓冲区溢出会**破坏程序运行**，也可以被用来**攻击计算机**，如**使用一个指向攻击代码的指针覆盖返回地址**。

## 2 缓冲区溢出示例

```c++
/**
 * 测试缓冲区溢出
 */
void test_cache_overflow() {
    char str[8];
    char input[256];
    gets(input);
    strcpy(str,input);
    printf("%s", str);
}
```

![](../../../media/202105/2021-05-24_163746.png)

1. 上面这段代码存在一个经典的缓冲区溢出漏洞`strcpy`。
2. 我们为`str`分配了8个字节的空间，输入小于等于8个字符，没问题。
3. 但当我们输入超长的数据时，就会出现问题，程序直接终止执行了。

## 3 防范缓冲区溢出攻击的方法

防范缓冲区溢出攻击的方法有三种，分别是**随机化**、**栈保护**和**限制可执行代码区域**。

### 3.1 随机化

1. 使用缓冲区溢出进行攻击，需要知道攻击代码的地址，因此常见的方法有：
   1. **栈随机化：** 程序开始时**在栈上分配一段随机大小的空间**。
   2. **地址空间布局随机化**（Address-Space Layout Randomization, ASLR）**：** 每次运行时**程序的不同部分**，包括代码段、数据段、栈、堆等都会**加载到内存空间的不同区域**。
2. 但是攻击者依然可以**使用蛮力克服随机化**，这种方式称为“空操作雪橇（Nop Sled）”，即**在实际的攻击代码前插入很长的一段 `nop`指令序列，执行这条指令只会移动到下一条指令**。
3. 因此只要攻击者能够猜中这段序列的某个地址，程序就会最终经过这段序列，到达攻击代码。
4. 因此**栈随机化和ASLR只能增加攻击一个系统的难度，但不能保证安全**。

### 3.2 栈保护

1. 在**发生缓冲区溢出，造成任何有害结果之前，尝试检测到他**。
2. 常用的栈破坏检测方法是**栈保护机制**，即**在每个函数的栈帧的局部变量和栈状态之间存储一个随机产生的特殊的值，称为金丝雀值**（Canary）。
3. 在**恢复寄存器状态**和**函数返回之前**，**程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止**。

### 3.3 限制可执行代码区域

1. 内存页的访问形式有三种：**可读**、**可写**、**可执行**。
2. 只有**编译器产生的那部分代码所处的内存才是可执行的**，**其它页**应当限制为**只允许读和写**。
3. 以前`x86`**将读和执行视为一个标志位**，**可读就可执行**，为了限制某些页可读但不可执行，往往会带来严重的性能损失。
4. 现在新的处理器**在硬件上引入新的位，将读和执行分开，由硬件来检查页是否可执行，效率上没有损失**。

## 4 参考文献

1. [缓冲区溢出问题](https://github.com/wolverinn/Waking-Up/blob/master/Operating%20Systems.md#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98)。
2. [【面试题】技术面试题汇总 🔥](https://imageslr.com/2020/07/08/tech-interview.html)。
3. [浅谈缓冲区溢出](https://zhuanlan.zhihu.com/p/21924662)。
