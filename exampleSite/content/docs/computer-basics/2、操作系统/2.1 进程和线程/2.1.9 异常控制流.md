---
weight: 9
---

# 异常控制流

## 1 什么是控制流

1. 假设在计算机运行过程中，其指令序列为 $a_1,a_2,...,a_n$，则每次从 $a_n$ 到 $a_{n+1}$ 的过渡叫做**控制转移**，而 $a_1,a_2,...,a_n$ 这条**完整的控制转移序列**叫做处理器的**控制流**。
2. 所以，控制流说白了就是**CPU 执行指令的序列**。

## 2 什么是控制流的异常

1. **程序在加载进内存时指令序列也会跟着一同被加载**。
2. **指令序列在内存中是相邻的**，**程序计数器**在通常情况下会**依次加载这些相邻的指令交给 CPU 执行**。
3. 但是**在某些情况下可能会发生突变**，从而**打破 CPU 本应该顺序执行这些指令序列的预期行为**，这种突变就叫做**控制流的异常**，简称**ECF**（Exception Control Flow）。

## 3 理解异常控制流的必要性

1. ECF 是操作系统用来**实现 I/O、进程和虚拟内存的基本机制**。
2. **陷阱和系统调用都是 ECF 的一种**。
3. 操作系统**实现并发机制依靠的也是 ECF**。
4. **类似于 `Java` 的 `try/catch` 异常机制，属于应用层的 ECF**。

## 4 异常处理程序

### 4.1 基本概念

1. 异常处理程序就是**处理异常的程序**。
2. 相关物理含义：
   1. **CPU 的状态：**
      1. CPU 的状态就是指其内部**特定范围的一些数据位和电信号**，CPU 状态的变化可以理解为这些**数据位或电信号的变化**。
      2. CPU 状态的变化可能与当前执行的应用程序的指令有关，比如**虚拟内存缺页、算术溢出、除以 0 等**，也有可能与当前执行的指令无关，比如**I/O 请求完成**。
   2. **CPU 的事件：**
      1. CPU 的状态变化就是 CPU 的事件。
   3. **异常表：**
      1. 在任何情况下，当 CPU 检测到有事件发生时，会通过一张映射表，找到一个被设计用来**专门处理这类事件的操作系统的子程序**，这个子程序就是**异常处理程序**。
      2. 而**记录不同类型的异常处理程序之间的映射关系的映射表就是异常表**。
      3. 异常表中对于每种可能类型的异常都分配了一个**唯一的非负整数的异常号**。
      4. 其中一些号码是由**CPU 的设计者**设计的，比如**零除异常、缺页异常、内存访问违规异常、算术运算溢出异常**，这些属于**系统无关的异常**。
      5. 而有一些异常号码则是由**操作系统内核的设计者**分配的，比如**系统调用**和**IO 设备的信号**，这些属于**系统相关的异常**。
      6. **操作系统在启动时会整合 CPU 异常和内核异常**，并且将其**记录成一张完整的异常表加载到内存中**，然后**将其起始地址放在**一个叫做**异常表基址寄存器**的一个**特殊的 CPU 寄存器**里。![](https://pic1.zhimg.com/80/v2-5516cba6d8724cc103bfdef556a3c430_1440w.jpg)![](https://pic4.zhimg.com/80/v2-90175805ab28300f5660034d8d35d7ff_1440w.jpg)
3. 异常处理的基本过程：
   1. 假设当前 CPU 正在执行的指令为`lcurr`，此时**CPU 检测到一个异常发生，进而 CPU 转去执行异常处理程序的相关指令**。
   2. 当异常处理程序执行完之后，根据其处理结果可能有几种动作：
      1. **继续执行异常发生时正在执行的应用程序的指令 `lcurr`**。
      2. **执行异常发生时正在执行的应用程序的指令 `lcurr` 的下一条指令 `lnext`**。
      3. 该应用程序**直接被终止，不再执行其指令**。
4. 无论是**硬件触发了异常**还是**软件触发了异常**，剩下的工作都是**由异常处理程序在软件中完成**。
5. 在处理程序处理完事件之后，可以通过执行一条特殊的“**从中断返回**”的指令可选的**返回到被中断的程序**。

### 4.2 异常分类

异常可以分为四类，分别为**中断、陷阱、故障、终止**。

> 同步异常和异步异常的区别？
>
> 1. **同步异常是指由当前程序本身引起的异常**，如**系统调用、缺页异常、段错误**（访问的内存超过了系统所给这个程序的内存空间）。
> 2. **异步异常是指由当前程序之外的因素引起的异常**，如**来自 IO 设备的信号**。

![](../../../media/202105/2021-05-19_114012.png)

#### 4.2.1 中断

1. **最常见的中断就是由IO设备引起的**，比如我们在进行网络IO时，当网卡收到数据时，需要**通知CPU将网卡缓冲区上的数据复制到内核缓冲区**。
2. 此时**网卡驱动会向CPU芯片的一个引脚发信号**，并且**将自己的异常号发到系统总线上**，这个**引脚信号触发了ECF**，**异常号标识这个ECF是中断**。
3. 当CPU执行完当前指令时发现**中断引脚的电压变高了**，此时会**从系统总线中读取异常号**，然后**从异常表中找到该异常对应的处理程序**，即中断处理程序**去处理异常**。
4. 当**中断处理程序结束后**，将**继续执行中断发生前执行指令的下一条指令**，所以对于应用层开发者来说，中断仿佛是不存在的，我们无法感知。
5. 由于指令的执行者是CPU，但**中断的发生**是随机的，**和CPU当前正在执行的指令毫无关系**，**所以是异步的**，而对于**陷阱、故障、终止**来说，这三种异常**是CPU执行当前指令所引起的**，**所以是同步的**，这类指令也叫做**故障指令**。

![](../../../media/202105/2021-05-20_094709.png)

#### 4.2.2 陷阱

1. 陷阱是**有开发人员控制应用程序主动引起的异常**，其最主要的用途是**给应用程序提供一个调用系统内核服务的接口**，也就是我们所熟悉的**系统调用**。
2. 由于**运行程序运行在用户态，是无法直接调用运行在内核态的内核服务**，比如**读文件read、创建新进程fork、加载新程序execve、终止当前进程exit**，但在某些场景之下我们又是极其需要这些内核服务支持的，比如读文件就是一个非常常见的需求。
3. **为了允许应用程序能够受控的访问这些内核服务，处理器提供了一条特殊指令 `syscall n`，当应用程序想调用编号为 `n`的内核服务时，就可以执行这条指令，执行 `syscall`指令会产生一个ECF，即陷阱**。
4. CPU在检测到陷阱时，会在异常表中找到其异常处理程序并执行，执行完之后将控制返还给**陷阱发生时正在执行指令的下一条指令**。

![](https://pic4.zhimg.com/80/v2-93edd6351eb6a23e26f5c215fd7076f7_1440w.jpg)

#### 4.2.3 故障

1. 故障是**由当前正在执行的指令引起的某种意外情况，这种意外情况可能能够被故障处理程序修复，也有可能修复不了**。
2. 假如当前正在执行的指令引起一个故障，处理器会从异常表中找到对应的故障处理程序：
   1. 如果能够**成功处理故障**，则**重新执行引起故障的命令**。
   2. 如果**故障处理失败**，则**终止当前应用程序**。
3. 比较典型的故障如**缺页故障**，当**指令引用一个虚拟地址**，而该**虚拟地址对应的物理页面不在内存中**时，就会发生缺页故障，**缺页处理程序会先将该页面从磁盘加载到内存中**，然后**重新运行引起故障的指令**。

![](../../../media/202105/2021-05-20_101219.png)

#### 4.2.4 终止

1. 终止可以理解为**不可恢复的故障**，通常是指**硬件故障**，比如**内存会磁盘损坏**。
2. 当发生终止时，终止处理程序**从不将控制返回给应用程序，而是将控制返回给 `abort`进程**，该进程会**终止引起故障的应用程序**。

![](../../../media/202105/2021-05-20_101708.png)

## 5 参考文献

1. [进程的异常控制流：陷阱、中断、异常和信号](https://github.com/wolverinn/Waking-Up/blob/master/Operating%20Systems.md#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%9A%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E4%BF%A1%E5%8F%B7)。
2. [（一）异常控制流](https://zhuanlan.zhihu.com/p/79083313)。
